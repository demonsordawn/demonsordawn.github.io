---
title: 时间复杂度
date: 2021-01-01 10:00:00
categories: 算法
---
### 堆排序
#### 堆排序是一种二叉堆数据结构的比较排序算法.它具有原地排序和不稳定排序的特点
#### 二叉堆
-完全二叉树结构:每个节点都有左右两个子节点，并且最底层的叶子节点都在同一层
-满足堆的性质:最大堆:每个节点的的值>=其子节点的值,根节点是最大的.最小堆:每个节点的值<=其子节点的值,根节点是最小的.
#### 堆排序步骤
```javaScript
function heapSort(arr) {
    const n = arr.length;
    
    // 构建最大堆
    for (let i = Math.floor(n/2) - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }
    
    // 逐个提取元素
    for (let i = n - 1; i > 0; i--) {
        [arr[0], arr[i]] = [arr[i], arr[0]];
        heapify(arr, i, 0);
    }
    
    return arr;
}

function heapify(arr, n, i) {
    let largest = i;
    let left = 2 * i + 1;
    let right = 2 * i + 2;
    
    if (left < n && arr[left] > arr[largest]) largest = left;
    if (right < n && arr[right] > arr[largest]) largest = right;
    
    if (largest !== i) {
        [arr[i], arr[largest]] = [arr[largest], arr[i]];
        heapify(arr, n, largest);
    }
}

// 使用示例
const arr = [12, 11, 13, 5, 6, 7];
console.log(heapSort(arr)); // [5, 6, 7, 11, 12, 13]
```
#### 时间复杂度
-构建堆:O(n)
-每次堆调整:O(logn)
-总复杂度:O(nlogn)
#### 特点
优点:
-时间复杂度稳定为O(nlogn)
-原地排序,时间复杂度为O(1)
-适用于大数据集排序
缺点:
-不稳定排序,相同元素的相对位置可能会发生变化
-常数因子较大,性能不如快速排序
-缓存不友好,跳跃式访问内存
#### 适用场景
-需要稳定O(nlogn)时间复杂度的排序算法
-内存受限的环境(原地排序)
-实时系统,最坏的情况性能有保障
### 快速排序
#### 基本思想
1.选择一个基准元素(pivot)
2.将数组分区:小于基准的放在左边,大于基准的放在右边
3.递归地排序左右两边的子数组
#### 算法步骤
``` javaScript
function quickSort(arr, low = 0, high = arr.length - 1) {
    if (low < high) {
        // 分区操作
        const pivot = arr[high];
        let i = low - 1;
        
        for (let j = low; j < high; j++) {
            if (arr[j] <= pivot) {
                i++;
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
        }
        
        // 放置基准到正确位置
        [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
        const pivotIndex = i + 1;
        
        // 递归调用
        quickSort(arr, low, pivotIndex - 1);
        quickSort(arr, pivotIndex + 1, high);
    }
    return arr;
}

// 使用示例
const arr = [10, 7, 8, 9, 1, 5];
console.log(quickSort([...arr])); // [1, 5, 7, 8, 9, 10]
```
#### 时间复杂度
- 平均时间复杂度:O(nlogn)
- 最坏时间复杂度:O(n^2)
- 最好时间复杂度:O(nlogn)
#### 特点
优点
- 平均性能极佳,通常是实践中最快的排序算法
- 原地排序,空间效率较高
- 缓存友好(局部性原理)
缺点:
- 最坏的情况性能较差(O(n^2))
- 不稳定排序
- 递归深度问题(可能栈溢出)

### 选择排序(冒泡排序)
#### 基本思想:不断地从未排序的部分中选择最小(或者最大)的元素将其放到已排序部分的末尾
#### 时间复杂度:O(n^2)

### 插入排序
#### 基本思想: 将待排序的元素插入到已经排好序的序列中的适当位置,直到全部插入完毕
#### 时间复杂度:O(n^2)