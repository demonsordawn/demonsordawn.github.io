---
title: 手写代码
tags: ['代码']
---
## 1. 手写call
- 作用: 立即调用函数,并允许你在指定函数内部的this值,以及以参数列表的形式传入参数
- 使用场景: 当年想要改变函数this的指向,并且函数需要立即执行,且参数个数明确时使用
```javascript
Function.prototype.myCall = function(context,...args){
    //1.处理context为null或undefined的情况
    if(context === null ){
        context = typeof window !== 'undefined' ? window :global;
    }
    //2. 将context包装为对象(防止原始类型)
    context = Object(context);

    //3.使用Symbol创建唯一键,避免属性冲突
    const fnKey = Symbol('fn');


    //4.将当前函数this绑定到context上
    context[fnKey] = this;

    //5.执行函数并保存结果
    const result = context[fnKey](..args);

    //6.删除临时属性
    delete context[fnKey];

    //7.返回执行结果
    return result;
}
```
### 面试问题:
1. 为什么用Symbol? 避免覆盖context上的原有属性
2. 为什么先Object(context)? 处理原始值(string,number等)
3. 为什么用context == null? 同时判断null和undefined

## 2. 手写apply
- 作用: 立即调用函数,并允许你指定函数内部的this值,以及以数组(或类数组对象)的形式传入参数
- 使用场景: 当你想改变函数this指向,并且函数需要立即执行,且参数个数不确定或者以数组形式给出时使用
##### apply和call方法的唯一区别是参数的传递方式不同
```javascript
Function.prototypr.myApply = function(context,argsArray){
    //处理context
    context = context || window;

    //创建唯一键
    const fnKey = Symbol('fn');

    //将函数绑定到context
    contest[fnKey] = this;

    //处理参数:apply接收数组或类数组对象
    let result;
    if(argsArray && typeof argsArray === 'object' && 'length' in argsArray){
        //使用Array.from方法将类数组对象转换为数组
        result = context[fnKey](...Array.form(argsArray));
    } else if(argsArray === undefined || argsArray ===null){
        result = context[fnKey];
    } else {
        throw new TypeError('参数必须为数组或类数组对象');
    }

    //清理
    delete context[fnKey];

    //返回结果
    return result;
}

//测试用例
obj.sayHello.apply(obj2,[25,'reading']);
obj.sayHello.myApply(obj2,[25,'reading']);
```
#### 面试解释要点:
- 与call的区别:参数处理方式
- 为什么要检查'length' in argsArray? 支持类数组对象
- 错误处理:参数不是对象时的处理

## 3.手写bind
- 作用:创建一个新的函数,这个新函数的this值被绑定到指定的对象,并且可以预先传入部分参数(柯里化),它不会立即执行函数,而是返回一个函数,供后续调用
- 使用场景: 当你想要改变this的指向,但不需要立即执行,而是想返回一个函数供以后调用时使用.也常用于回调函数中固定this指向
```javascript
Function.prototype.myBind = function(context,bindArgs){
    //1. 保存原函数和this
    const originalFunc = this;

    //2. 参数校验
    if(typeof originalFunc !== 'function'){
        throw new TypeError('bind muse be called on a function');
    }

    //3. 返回绑定函数
    const boundFunc = function(...callargs){
        //4. 判断是否通过new调用
        const isNewCall = this instanceof boundFunc;

        //5.确定执行上下文:new 调用忽略绑定的context
        const actualContext = isNewCall ? this : context || window;

        //6.执行原函数
        return originalFunc.apply(actualContext,bindArs.concat(callargs));
    };
    
    //7.维护原型关系
    if(originalFunc.prototype){
        //使用Object.create保持原型链
        boundFunc.prototype = Object.create(originalFunc.prototype);
        boundFunc.prototype.constructor = boundFunc;
    }
}
```

#### 面试要点:
- 为什么需要判断new调用?new操作符会创建新对象,此时应忽略绑定的this
- 原型链维护的重要性:确保instanceof操作符的正确性
- 柯里化实现: 支持参数的分次传递

#### 常见追问问题
- Q: call和apply的性能差异
- A: apply在参数多时稍慢,因为需要处理数组展开
- Q: 为什么bind返回的函数不能再次修改?
- A: 硬绑定特性,确保this指向稳定
- Q: 箭头函数能用call/apply/bind吗?
- A: 不能,箭头函数的this在定义时确认,无法修改
- Q: Symbol不兼容怎么办?
- A: 可以用Date.now()或随机数生成唯一key